\documentclass{article}
\usepackage{mathtools}
\usepackage[utf8]{inputenc}
\usepackage{tikz,pgfplots,filecontents,amsmath}
\pgfplotsset{compat=1.5}

\begin{filecontents}{data.dat}
 n   xn 
 0   1  
 1   0  
 2   0
 3   0
 4   0
 5   0
 6   0
 7   0
 8   0
\end{filecontents}

\title{Counting Submultiset Combinations}
\author{Charles Dunn}
\date{August 2018}

\usepackage{natbib}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{bm}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{breqn}
\usepackage{color}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\setcounter{MaxMatrixCols}{13}

\newcommand{\Conv}{\mathop{\scalebox{1.5}{\raisebox{-0.2ex}{$\ast$}}}}%


\begin{document}

\maketitle

\section{Introduction}

Many games involve selecting a few items from a larger group. Examples include dealing hands from a deck in card games or selecting tiles in Scrabble. It is a common method of introducing randomness. To inform strategy or to formalize a process with random subset selection, it is useful to exhaustively count the number of combinations of a given number of items randomly selected from a group. Note that we are not considering the order of the selected items since games like Poker and Scrabble are agnostic to hand order; we are interested in the number of combinations, not the number of permutations.

Formally, the purpose of this paper is to derive an analytical solution and implement a fast algorithm for $\bm{C}(\bm{m})[k]$, the number of combinations of $k$ items selected without replacement from the multiset $S$ with multiplicity $\bm{m}$. 

It is worth noting that no constraints should be applied to $S$ in the final solution. The binomial coefficient (i.e. ``n choose k'') suffices as a solution to our problem only for sets without repeated elements\footnote{Sets do not account for repeated elements, while multisets can have multiple instances of the same type. Sets are a special case of multisets.}, but overcounts if there are any repeated (i.e. interchangeable) elements in $S$. An example of a set for which the binomial coefficient is sufficient is the standard deck of playing cards. One example of a multiset with repetition is the tiles in Scrabble, where there are twelve identical `E' tiles and various quantities of other tile types. Our desired solution for $\bm{C}(\bm{m})[k]$ will provide the correct value regardless of the structure of $S$.

In the conclusion, we will show the calculated values using our solution and implementation of $\bm{C}(\bm{m})[k]$ for the number of possible starting hands in Scrabble, Hanabi, and Mahjongg.

\section{Formalization}

Let $S$ be the full multiset of $n$ items from which a submultiset will be selected.
\begin{equation}
    n = \left | S \right | 
\end{equation} 
\begin{equation}
    S = \{ s_1, s_2, ..., s_n\}
\end{equation} 
Let $A$ be the unique set of $u$ item types from which $S$ is constructed. This is the set of all possible item types. Every item in $S$ is in $A$ exactly once.
\begin{equation}
    A = \{ a_1, a_2, ..., a_u\} = \bigcup_{s\in S} s
\end{equation} 
\begin{equation}
    u = \left | A \right | 
\end{equation} 
Let $\bm{m} \in \mathbb{Z}_{*}^{u}$ be the multiplicity of $S$. This is just a count of the number of occurrences of each item type in the full multiset $S$. That is, the $j$th element of $\bm{m}$, $m_j$, is the count of items in $S$ with item type $a_j \in A$.

To calculate $m_j$ from $S$, iterate over all elements of $S$ and increment the count for each item of type $a_j$.
\begin{equation}
    m_j = \sum_{s \in S} \mathbbm{1}_{a_j}(s) = \sum_{i = 1}^n \begin{cases}1 & s_i = a_j \\ 0 & \text{else} \end{cases}
\end{equation} 

Note that the number of unique item types in $S$ is just the size of the multiplicity.
\begin{equation}
    u = |\bm{m}|
\end{equation} 

We will use sub- and superscript notation to denote a range of $\bm{m}$. As an example, $\bm{m}_{1}^{u - 1}$ is all but the last element of $\bm{m}$.

\section{Analytical Solution}

To restate our goal, we are looking for an analytical solution for $C(\bm{m})[k] \in \mathbb{Z}_{*}$, the count of combinations of $k \in \mathbb{Z}$ items selected without replacement from a multiset with multiplicity $\bm{m} \in \mathbb{Z}_{+}^u$ of $u$ unique item types.

\subsection{Preparation}

 We will use induction to solve for $C(\bm{m})[k]$, but we must first prove two things: how to solve for $C(\bm{m})[k]$ from the combination of two disjoint multisets, and how to segment a multiset into disjoint submultisets.


% \begin{tikzpicture}
% \begin{axis}
% [%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     axis x line=bottom,
%     axis y line=middle,
%     axis equal image,
%     every axis x label={at={(current axis.right of origin)},anchor=north west},
%     every axis y label={at={(current axis.above origin)},anchor= north west},
%     xlabel={$k$},
%     ylabel={${C([])[k]}$},
%     xtick={0, 1, 2, 3, 4, 5, 6, 7, 8},
%     ymin=0,
%     ymax=1,
%     ytick={1},
% ]%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \addplot+[ycomb,black,thick] table [x={n}, y={xn}] {data.dat};
% \end{axis}
% \end{tikzpicture}

\subsubsection{Disjoint Multiset Union} \label{union}

We will show that combining two disjoint multisets results in a convolution of their combination counting functions.\footnote{Convolution is an incredibly powerful mathematical concept, and has applications in signal processing, statistics, algebra, machine learning, and more. It is worth researching if you have not encountered it before.} The convolution of two discrete functions $f[\cdot]$ and $g[\cdot]$ is represented as $(f * g)[\cdot]$.
\begin{equation}
     (f * g)[x] \equiv \sum_{\gamma=-\infty}^{\infty} f[\gamma]g[x - \gamma]
\end{equation}

Let $S_p$ and $S_q$ be two disjoint multisets we combine to form multiset $S$. Disjoint multisets have no elements in common. 
\begin{equation}
    \varnothing = S_p \cap S_q
\end{equation}
\begin{equation}
    S = S_p \uplus S_q
\end{equation}

As always, for any multiset $S_p$ we can derive the multiplicity $\bm{p}$, number of elements $n_p$, set of item types $A_p$, and number of item types $u_p$. The same notation holds for $S_q$.

$C(\bm{m}_p)[\cdot]$ is the combination count function for $S_p$ and $C(\bm{m}_q)[\cdot]$ is the combination count function for $S_q$. We will solve for $C(\bm{m})[\cdot]$, the combination count function for $S$, in terms of the other two functions.

For each combination of $k$ items from $A$, $k_p \in [0, k]$ items are from $A_p$ and $k_q\in [0, k]$ items are from $A_q$. Furthermore, the sum of items selected from the two multisets must equal the total number of items selected.
\begin{equation}
    k = k_p + k_q
\end{equation}

$C(\bm{m}_p)[\cdot]$ and $C(\bm{m}_q)[\cdot]$ are independent organizations; for each combination of items from $S_p$ counted by $C(\bm{m}_p)[k_p]$, there are exactly $C(\bm{m}_q)[k_q]$ combinations of the remaining items from $S_q$. Therefore, for a given $k_p$, the count of combinations of $k$ items from $S$ is simply the product of the two known combination counts.
\begin{equation}
    C(\bm{m}; k_p)[k] = C(\bm{m}_p)[k_p] \cdot C(\bm{m}_q)[k_q] = C(\bm{m}_p)[k_p] \cdot C(\bm{m}_q)[k - k_p]
\end{equation}

For any combination of $k$ items, $k_p$ is at least $0$ and at most $k$. The sum of the above equation over all values of $k_1$ exactly counts all combinations of $k$ items.
\begin{equation}
    C(\bm{m})[k] = \sum_{k_p = 0}^{k} C(\bm{m}; k_p)[k] = \sum_{k_p = 0}^{k} C(\bm{m}_p)[k_p] \cdot C(\bm{m}_q)[k - k_p]
\end{equation}

$C(\bm{m})[k]=0$ for any $k<0$, since there is no way to ever select a negative number of items for a multiset. Since $C(\bm{m}_p)[k_p] = 0$ when $k_p < 0$ and $C(\bm{m}_q)[k - k_1] = 0$ when $k_p > k$, we can make the sum infinite without affecting the value.
\begin{equation}
    C(\bm{m})[k] = \sum_{k_p = -\infty}^{\infty} C(\bm{m}_p)[k_p] \cdot C(\bm{m}_q)[k - k_p]
\end{equation}

This is the convolution of the two functions.
\begin{equation}
    C(\bm{m})[k] = (C(\bm{m}_p) * C(\bm{m}_q))[k]
\end{equation}

To summarize, we have proved that when joining two disjoint multisets, the resulting combination count is a convolution of the input combination counts.

\subsubsection{Disjoint Submultiset Segmentation} \label{segment}

The above result is only useful if we know how to create two disjoint submultisets from a multiset $S$. There are many ways to do this, but we will focus on creating a disjoint submultisets where one has only one item type. Specifically, let $S$ be the multiset with at least two item types for which we would like a combination count function. 
\begin{equation}
    S = \{a_1^{m_1}, a_2^{m_2}, ... a_u^{m_u}\}
\end{equation}
\begin{equation}
    u>1
\end{equation}

Let $S_p$ be the multiset containing all elements in $S$ of type $a_1$.
\begin{equation} \label{segment_eq1}
    S_p = \{a_1^{m_1}\}
\end{equation}

Let $S_q$ be a multiset containing all the remaining elements of $S$.
\begin{equation}
    S_q = S \setminus S_p
\end{equation}

Obviously, multisets $S_p$ and $S_q$ are disjoint, but their union covers the entire original set $S$.

The multiplicities of the resulting sets are easily defined. Let $\bm{p}$ and $\bm{q}$ be the respective multiplicities of multisets $S_p$ and $S_q$. $\bm{p}$ is just the first element of $\bm{m}$, which should be obvious from equation \ref{segment_eq1}. $\bm{q}$ is simply the remaining elements.
\begin{equation}
    \bm{p} = [m_1]
\end{equation}
\begin{equation}
    \bm{q} = \bm{m}_2^u
\end{equation}

Therefore, $\bm{m}$ is just the concatenation of $\bm{p}$ and $\bm{q}$.
\begin{equation}
    \bm{m} = [\bm{p}, \bm{q}]
\end{equation}

\subsection{Proof by Induction}

We can now demonstrate through inductive reasoning how to define a recursive solution for $C(\bm{m})[\cdot]$ for any multiset $S$.

\subsubsection{Base Case}

As with any proof by induction, we start with base cases, one of them trivial. 

If multiset $S$ is empty, there is exactly one combination of zero items that can be selected from it, and zero combinations of any other number of items. If $S$ is empty, $n=0$ and $u=0$.
\begin{equation}
    C(\bm{m})[k] = \delta_0[k] = \begin{cases}1 & k = 0 \\ 0 & \text{else}  \end{cases} \text{ if } u=0
\end{equation}

For reasons that will be obvious soon, we can express this case in terms of a rectangular function of width $n=0$.
\begin{equation}
    C(\bm{m})[k] = \delta_0[k] = \Pi_n[k] \text{ if } u=0
\end{equation}

The second trivial case is where $S$ has only one item type, so $u=1$. This is equivalent to $\bm{m}$ having only one element. Since $n$ is the number of items in the multiset, if $\bm{m}$ has only one element, it must be $n$. This simplicity means counting the possible combinations is relatively clear. If the entire multiset of $n$ items is composed of identical items, then there is exactly one combination of $k$ items if $k \leq n$ and exactly zero combinations otherwise.
\begin{equation}
    C(\bm{m})[k] = \Pi_n[k] = \begin{cases}1 & 0 \leq k \leq n \\ 0 & \text{else}  \end{cases}\text{ if } u = 1
\end{equation}

In both cases, when $S$ has zero or one item type, our solution for $C(\bm{m})[k]$ is the same, so we can combine them.
\begin{equation}
    C(\bm{m})[k] = \Pi_n[k] = \begin{cases}1 & 0 \leq k \leq n \\ 0 & \text{else}  \end{cases}\text{ if } u\leq 1
\end{equation}

\subsubsection{Inductive Step}

In all other cases, $S$ has at least two item types, and $\bm{m}$ has at least two elements. When this is the case, we can always break up $S$ into two disjoint submultisets, as shown in section \ref{segment}, and recombine their combination counting functions, as shown in section \ref{union}.
\begin{equation}
    C(\bm{m})[k] = (C([m_1]) * C(\bm{m}_2^u))[k]\text{ if } u>1
\end{equation}

\subsubsection{Recursive Solution}

We can now recursively define $C(\bm{m})[k]$ since we have a base case and an inductive step.
\begin{equation}
    C(\bm{m})[k] = \begin{cases}\Pi_n[k] & u \leq 1 \\
    (C([m_1]) * C(\bm{m}_2^u))[k] & \text{else} \end{cases}
\end{equation}

Note that we actually solved for the function regardless of $k$. This has implications for optimization when we implement the solution. \begin{equation} \label{rec}
    C(\bm{m}) = \begin{cases}\Pi_n & u \leq 1 \\
    C([m_1]) * C(\bm{m}_2^u) & \text{else} \end{cases}
\end{equation}

We have our first version of an analytical solution for the number of combinations of items from a multiset!

\subsection{Iterative Solution}

We would like to get our solution into a more practical form. To introduce some convenient notation, let $\Conv_{i=1}^N f_i$ be the convolution of the $N$ functions $f_1, f_2, ..., f_N$. 
\begin{equation}
    \Conv_{i=1}^N f_i = f_1 * f_2 * ... * f_N
\end{equation}
In the special case that $N=1$, we will just get the first function back.\footnote{This is all very similar to the better-known summation $\Sigma_{i=1}^N$ and product $\Pi_{i=1}^N$ notations.}
\begin{equation}
    \Conv_{i=1}^1 f_i = f_1
\end{equation}

If we perpetually replace the recursive parts of our previous solution, we arrive at a rather elegant one. The first part of the convolution in (\ref{rec}) is simply a rectangular function since it meets the condition that $u\leq 1$. The second will once again split the first element of $\bm{m}_2^u$ off from the rest.\footnote{This is not rigorous since have not constrained $u$ to be at least 3, but it is conceptually sound.} With one step down the recursion tree, we get the following.
\begin{equation}
    C(\bm{m}) = \begin{cases}\Pi_n & u \leq 1 \\
    \Pi_{m_1} * (C([m_2]) * C(\bm{m}_3^u)) & \text{else} \end{cases}
\end{equation}
It should now be clear that after repeated applications, we arrive at a long chain of convolved rectangular functions.
\begin{equation}
    C(\bm{m}) = \begin{cases}\Pi_n & u \leq 1 \\
    \Pi_{m_1} * (\Pi_{m_1} * (... * \Pi_{m_u})...)) & \text{else} \end{cases}
\end{equation}
Convolution is a linear operation is therefore associative.
\begin{equation}
    C(\bm{m}) = \begin{cases}\Pi_n & u \leq 1 \\
    \Pi_{m_1} * \Pi_{m_1} * ... * \Pi_{m_u} & \text{else} \end{cases}
\end{equation}
We can now apply our convenient notation, and revel in the fact that both cases collapse to one.
\begin{equation}
    C(\bm{m}) = \Conv_{i=1}^u \Pi_{m_i}
\end{equation}
This is a magnificently elegant analytical solution to a potentially ugly problem. It means that for any multiset with $u$ item types, regardless of its structure, we can solve for the number of combinations of any number of items simply by doing $u-1$ convolutions of $u$ rectangular functions.

\section{Implementation}

\pagebreak


\section{Examples}

\subsection{Scrabble}

\begin{equation}\nonumber
    S = \left \{
    \parbox{32em}{A, A, A, A, A, A, A, A, A, B, B, C, C, D, D, D, D, E, E, E, E, E, E, E, E, E, E, E, E, F, F, G, G, G, H, H, I, I, I, I, I, I, I, I, I, J, K, L, L, L, L, M, M, N, N, N, N, N, N, O, O, O, O, O, O, O, O, P, P, Q, R, R, R, R, R, R, S, S, S, S, T, T, T, T, T, T, U, U, U, U, V, V, W, W, X, Y, Y, Z, blank, blank}\right \}
\end{equation}

\begin{equation}\nonumber
    n = 100
\end{equation}

\begin{equation}\nonumber
    A = \left \{
    \parbox{32em}{A, B, C, D, E, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, blank}\right \}
\end{equation}

\begin{equation}\nonumber
    u = 27
\end{equation}

\begin{equation}\nonumber
    r_{\max} = 12
\end{equation}

\begin{equation}\nonumber
    \bm{\rho} = [5, 10, 1, 4, 0, 3, 0, 1, 2, 0, 0, 1]
\end{equation}

\subsection{Hanabi}

\begin{equation}\nonumber
    S = \left \{\\
    \parbox{32em}{
     \color{magenta}1\color{black}, \color{magenta}1\color{black}, \color{magenta}1\color{black}, \color{magenta}2\color{black}, \color{magenta}2\color{black}, \color{magenta}3\color{black}, \color{magenta}3\color{black}, \color{magenta}4\color{black}, \color{magenta}4\color{black}, \color{magenta}5\color{black}, \color{green}1\color{black}, \color{green}1\color{black}, \color{green}1\color{black}, \color{green}2\color{black}, \color{green}2\color{black}, \color{green}3\color{black}, \color{green}3\color{black}, \color{green}4\color{black}, \color{green}4\color{black}, \color{green}5\color{black}, \color{blue}1\color{black}, \color{blue}1\color{black}, \color{blue}1\color{black}, \color{blue}2\color{black}, \color{blue}2\color{black}, \color{blue}3\color{black}, \color{blue}3\color{black}, \color{blue}4\color{black}, \color{blue}4\color{black}, \color{blue}5\color{black}, \color{yellow}1\color{black}, \color{yellow}1\color{black}, \color{yellow}1\color{black}, \color{yellow}2\color{black}, \color{yellow}2\color{black}, \color{yellow}3\color{black}, \color{yellow}3\color{black}, \color{yellow}4\color{black}, \color{yellow}4\color{black}, \color{yellow}5\color{black}, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5
     }\right \}
\end{equation}

\begin{equation}\nonumber
    n = 50
\end{equation}

\begin{equation}\nonumber
    A = \left \{
     \color{magenta}1\color{black}, \color{magenta}2\color{black}, \color{magenta}3\color{black},  \color{magenta}4\color{black}, \color{magenta}5\color{black}, \color{green}1\color{black}, \color{green}2\color{black}, \color{green}3\color{black},  \color{green}4\color{black}, \color{green}5\color{black}, \color{blue}1\color{black}, \color{blue}2\color{black}, \color{blue}3\color{black}, \color{blue}4\color{black}, \color{blue}5\color{black}, \color{yellow}1\color{black}, \color{yellow}2\color{black},  \color{yellow}3\color{black}, \color{yellow}4\color{black}, \color{yellow}5\color{black}, 1, 2, 3, 4, 5\right \}
\end{equation}

\begin{equation}\nonumber
    u = 25
\end{equation}

\begin{equation}\nonumber
    r_{\max} = 3
\end{equation}

\begin{equation}\nonumber
    \bm{\rho} = [5, 15, 3]
\end{equation}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
